generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ------------------------------------------------------
// ENUMS
// ------------------------------------------------------

enum ProofType {
  DOCUMENT
  IMAGE
  VIDEO
  AUDIO
  CODE
  OTHER
}

enum IpType {
  COPYRIGHT
  TRADEMARK
  PATENT
  DESIGN
  UNKNOWN
}

enum LegalStatus {
  UNVERIFIED
  ANCHORED      // anchored on primary chain
  ADMISSIBLE    // meets evidence bar (e.g., platform-signed + chain receipts)
  REGISTERED    // synced with official registry / affidavit on file
}

enum AnchorNetwork {
  HEDERA
  ETH_L2
  BTC_OTS
  OTHER
}

enum SignatureAlgo {
  ED25519
  ECDSA_P256
  RSA_PSS
  OTHER
}

enum DigestAlgo {
  SHA256
  SHA3_256
  OTHER
}

enum AuditAction {
  LOGIN
  LOGOUT
  TOKEN_REFRESH
  PROOF_CREATE
  PROOF_VERIFY_PUBLIC
  PROOF_CERTIFICATE_ISSUE
  WALLET_LINK
  WALLET_UNLINK
  AI_REGENERATE_SUMMARY
  LEGAL_ANCHOR
  LEGAL_STATUS_UPDATE
}

// ------------------------------------------------------
// MODELS
// ------------------------------------------------------

model User {
  id              String          @id @default(uuid())
  email           String          @unique
  passwordHash    String
  fullName        String?
  walletPublicKey String?         @unique
  jurisdiction    String?         // e.g. "NG", "US", "EU"
  termsVersionAccepted String?    // current accepted version tag (e.g. "tos-1.0")
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  refreshTokens   RefreshToken[]
  proofs          Proof[]
  auditLogs       AuditLog[]
  termsAcceptances TermsAcceptance[] // history (optional)

  @@index([email])
}

// Optional consent history for legal defensibility
model TermsAcceptance {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  version     String   // "tos-1.0"
  acceptedAt  DateTime @default(now())
  ipAddress   String?
  userAgent   String?

  @@index([userId, version])
}

// ------------------------------------------------------

model RefreshToken {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  hashedJti  String   @unique
  revokedAt  DateTime?
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
}

// ------------------------------------------------------

model Proof {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

// New for legal posture
  legalStatus        LegalStatus @default(UNVERIFIED)
  jurisdiction       String?         // snapshot at time of creation
  legalClauseVersion String?         // e.g. "legal-clause-v1.0"
  platformSignature  String?         // base64 signature by IPProtect key (for certificate/admissibility)

  // Evidence context
  proofType      ProofType?          // you defined enum; now use it

  filename      String
  mimeType      String
  sizeBytes     Int
  sha256        String   @unique
  ipType        IpType   @default(UNKNOWN)

  // Optional external references
  ipfsCid       String?
  hederaTxId    String?  @unique
  hederaTopicId String?
  hederaConsensusAt DateTime? // consensus timestamp

  // Relations
  aiSummary     ProofAIInsight?
  signatures    ProofSignature[]
  auditLogs     AuditLog[]
  anchors       ProofAnchor[]        // NEW: multi-chain receipts
  certificates  ProofCertificate[]   // optional: certificate issuance history

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])   // pagination
  @@index([ipType])
   @@index([legalStatus])
  @@index([jurisdiction])
}

model ProofAnchor {
  id         String        @id @default(uuid())

  proofId    String
  proof      Proof         @relation(fields: [proofId], references: [id], onDelete: Cascade)

  network    AnchorNetwork
  txId       String?       // chain txId or receipt reference
  anchorRef  Json?         // arbitrary receipt: block no, merkleRoot, state proof, etc.
  anchoredAt DateTime?     // chain finality timestamp
  status     String?       // e.g. "CONFIRMED", "PENDING", "FAILED"

  @@unique([proofId, network, txId])
  @@index([proofId, network])
}

model ProofCertificate {
  id          String   @id @default(uuid())
  proofId     String
  proof       Proof    @relation(fields: [proofId], references: [id], onDelete: Cascade)

  version         Int        // incremental issuance counter
  serial          String     @unique // human-friendly identifier
  clauseVersion   String     // e.g. "legal-clause-v1.0"
  issuedAt        DateTime   @default(now())
  pdfSha256       String?    // hash of the rendered PDF (evidence chain)
  platformSignature String?  // signature over the certificate hash
  publicVerifyUrl String?    // frozen URL including hash param

  @@unique([proofId, version])
  @@index([proofId, issuedAt])
}

// ------------------------------------------------------
// 1:1 AI summary â€” FK owned here on ProofAIInsight.proofId
// ------------------------------------------------------
model ProofAIInsight {
  id          String   @id @default(uuid())

  proofId     String   @unique
  proof       Proof    @relation(fields: [proofId], references: [id], onDelete: Cascade)

  summary     Json     // { title, description, category, ... }
  modelUsed   String
  generatedAt DateTime @default(now())
}

// ------------------------------------------------------
// 1:N Signatures per proof (wallet/identity signatures)
// ------------------------------------------------------
model ProofSignature {
  id         String   @id @default(uuid())

  proofId    String
  proof      Proof    @relation(fields: [proofId], references: [id], onDelete: Cascade)

  signerName String?
  walletAddr String?
  signature  String?  // base64 sig (over digest), or JWS string
  signedAt   DateTime @default(now())

  @@index([proofId])
  @@index([walletAddr])
}

// ------------------------------------------------------
// Optional: Audit trail for future compliance / admin
// ------------------------------------------------------

model AuditLog {
  id         String   @id @default(uuid())

  userId     String?
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  proofId    String?
  proof      Proof?   @relation(fields: [proofId], references: [id], onDelete: Cascade)

  action     AuditAction    // enum for standardization
  jurisdiction String?      // snapshot for legal context
  entityType String 
  entityId   String
  details    Json?
  ipAddress  String?
  userAgent  String?

  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([proofId])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([action, createdAt])
}

